#!/bin/bash

# ============================================================================
# BASH CONFIGURATION GENERATOR SCRIPT
# ============================================================================
# Generates bash configuration files from environment variables at runtime
# Optimized for DockerKit local development environment
# ============================================================================
set -euo pipefail

readonly BASH_HISTSIZE=10000       # History size
readonly BASH_HISTFILESIZE=20000   # History file size

# User configurable (optional tools that may conflict)
readonly FZF_ENABLED="${ENABLE_FZF:-1}"
readonly STARSHIP_ENABLED="${ENABLE_STARSHIP:-1}"

# Color output functions
log_ok() { echo -e "[$SCRIPT_NAME] \033[32m[OK]\033[0m $*"; }
log_warn() { echo -e "[$SCRIPT_NAME] \033[33m[WARN]\033[0m $*"; }
log_error() { echo -e "[$SCRIPT_NAME] \033[31m[ERROR]\033[0m $*"; }
log_info() { echo "[$SCRIPT_NAME] $*"; }

SCRIPT_NAME=$(basename "$0")
readonly SCRIPT_NAME
readonly USER_HOME="/home/${APP_USER}"

# ============================================================================
# Validation and utilities
# ============================================================================
validate_environment() {
    local errors=0

    if ! id "${APP_USER}" >/dev/null 2>&1; then
        log_error "User ${APP_USER} does not exist"
        ((errors++))
    fi

    if [ ! -d "${USER_HOME}" ]; then
        log_error "Home directory ${USER_HOME} does not exist"
        ((errors++))
    fi

    if [ ! -w "${USER_HOME}" ]; then
        log_error "No write permissions to ${USER_HOME}"
        ((errors++))
    fi

    return $errors
}



create_file_safely() {
    local file_path="$1"
    local temp_file="${file_path}.tmp"

    # Create temporary file
    if ! cat > "$temp_file"; then
        log_error "Failed to create temporary file: $temp_file"
        return 1
    fi

    # Check file is not empty
    if [ ! -s "$temp_file" ]; then
        log_error "Generated file is empty: $temp_file"
        rm -f "$temp_file"
        return 1
    fi

    # Atomic move
    if ! mv "$temp_file" "$file_path"; then
        log_error "Failed to move file to final location: $file_path"
        rm -f "$temp_file"
        return 1
    fi

    log_ok "Created: $file_path"
    return 0
}

set_ownership() {
    if chown "${APP_USER}:${APP_GID}" "${USER_HOME}/.bashrc" "${USER_HOME}/.bash_aliases" 2>/dev/null; then
        log_ok "Set proper file ownership"
        return 0
    else
        log_warn "Could not set file ownership (non-critical)"
        return 1
    fi
}

# ============================================================================
# Shell environment configuration
# ============================================================================
setup_shell_environment() {
    cat << EOF

# === Shell Detection Fix ===
export SHELL=/bin/bash
export BASH_ENV=${USER_HOME}/.bashrc
export ENV=${USER_HOME}/.bashrc

# Ensure bash is properly detected
if [ -n "\$BASH_VERSION" ]; then
    export SHELL_NAME=bash
    export CURRENT_SHELL=bash
fi
EOF
}



# ============================================================================
# Input/readline configuration for better tab completion
# ============================================================================
setup_inputrc() {
    log_info "Setting up readline configuration for better tab completion..."

    if create_file_safely "${USER_HOME}/.inputrc" << 'EOF'; then
# ~/.inputrc - readline configuration for improved tab completion
# DockerKit optimized settings

# UTF-8 and locale support
set input-meta on
set output-meta on
set convert-meta off

# Show completions immediately on first Tab press
set show-all-if-ambiguous on

# Show completions immediately if nothing has changed
set show-all-if-unmodified on

# Case insensitive completion
set completion-ignore-case on

# Match case variations (e.g., Test -> test)
set completion-map-case on

# Colorize the common prefix of completions
set colored-completion-prefix on

# Don't ask before showing completions
set completion-query-items -1

# Show completions in multiple columns
set print-completions-horizontally off

# Page completions if too many
set page-completions off

# Don't ring bell on completion
set bell-style none

# Visual improvements for completion
set visible-stats on
set colored-stats on
set mark-directories on

# Better history navigation
"\e[A": history-search-backward
"\e[B": history-search-forward

# Alt+Left/Right for word navigation
"\e[1;3D": backward-word
"\e[1;3C": forward-word

# Ctrl+Left/Right for word navigation (alternative)
"\e[1;5D": backward-word
"\e[1;5C": forward-word
EOF
        chown "${APP_USER}:${APP_GID}" "${USER_HOME}/.inputrc" 2>/dev/null || true
        log_ok "Created readline configuration for improved tab completion"
    else
        log_error "Failed to create readline configuration"
        return 1
    fi
}

# ============================================================================
# Color configuration
# ============================================================================
setup_colors() {
    cat << 'EOF'

# === Color support configuration ===
export FORCE_COLOR=1
export CLICOLOR=1
export CLICOLOR_FORCE=1
export COMPOSER_NO_ANSI=0

# Configure Git colors
if command -v git >/dev/null 2>&1; then
    git config --global color.ui auto
    git config --global color.branch auto
    git config --global color.diff auto
    git config --global color.status auto
fi

# Terminal color support
if [[ -t 1 ]]; then
    export COLORTERM=truecolor
    export TERM=xterm-256color
fi
EOF
}

# ============================================================================
# Laravel artisan completion (static implementation for performance)
# ============================================================================
setup_laravel_completion() {
    cat << 'EOF'

# Laravel artisan completion - static implementation
# Based on Symfony Console completion template for optimal performance
if command -v php >/dev/null 2>&1; then
    # Static completion function (no dynamic Laravel bootstrap)
    _sf_artisan() {
        # Use newline as only separator to allow space in completion values
        IFS=$'\n'
        local sf_cmd="${COMP_WORDS[0]}"

        # for an alias, get the real script behind it
        sf_cmd_type=$(type -t "$sf_cmd")
        if [[ $sf_cmd_type == "alias" ]]; then
            sf_cmd=$(alias "$sf_cmd" | sed -E "s/alias $sf_cmd='(.*)'/\1/")
        elif [[ $sf_cmd_type == "file" ]]; then
            sf_cmd=$(type -p "$sf_cmd")
        fi

        if [[ $sf_cmd_type != "function" && ! -x "$sf_cmd" ]]; then
            return 1
        fi

        local cur prev words cword
        _get_comp_words_by_ref -n := cur prev words cword

        local completecmd=("$sf_cmd" "_complete" "--no-interaction" "-sbash" "-c$cword")
        for w in ${words[@]}; do
            w=$(printf -- '%b' "$w")
            # remove quotes from typed values
            quote="${w:0:1}"
            if [ "$quote" == \' ]; then
                w="${w%\'}"
                w="${w#\'}"
            elif [ "$quote" == \" ]; then
                w="${w%\"}"
                w="${w#\"}"
            fi
            # empty values are ignored
            if [ ! -z "$w" ]; then
                completecmd+=("-i$w")
            fi
        done

        local sfcomplete
        if sfcomplete=$(${completecmd[@]} 2>&1); then
            local quote suggestions
            quote=${cur:0:1}

            # Use single quotes by default if suggestions contains backslash (FQCN)
            if [ "$quote" == '' ] && [[ "$sfcomplete" =~ \\ ]]; then
                quote=\'
            fi

            if [ "$quote" == \' ]; then
                # single quotes: no additional escaping (does not accept ' in values)
                suggestions=$(for s in $sfcomplete; do printf $'%q%q%q\n' "$quote" "$s" "$quote"; done)
            elif [ "$quote" == \" ]; then
                # double quotes: double escaping for \ $ ` "
                suggestions=$(for s in $sfcomplete; do
                    s=${s//\\/\\\\}
                    s=${s//\$/\\\$}
                    s=${s//\`/\\\`}
                    s=${s//\"/\\\"}
                    printf $'%q%q%q\n' "$quote" "$s" "$quote";
                done)
            else
                # no quotes: double escaping
                suggestions=$(for s in $sfcomplete; do printf $'%q\n' $(printf '%q' "$s"); done)
            fi
            COMPREPLY=($(IFS=$'\n' compgen -W "$suggestions" -- $(printf -- "%q" "$cur")))
            __ltrim_colon_completions "$cur"
        else
            if [[ "$sfcomplete" != *"Command \"_complete\" is not defined."* ]]; then
                >&2 echo
                >&2 echo $sfcomplete
            fi
            return 1
        fi
    }

    # Register completion for multiple artisan command variants
    complete -F _sf_artisan artisan
    complete -F _sf_artisan art

    # Fast command functions without dynamic completion setup
    artisan() {
        php artisan --ansi "$@"
    }

    art() {
        php artisan --ansi "$@"
    }
fi
EOF
}

# ============================================================================
# Generate .bash_aliases (always full set for development)
# ============================================================================
generate_aliases_content() {
    cat << 'EOF'
# Laravel/PHP aliases (artisan/art handled by functions in bashrc)
alias fresh='php artisan migrate:fresh --ansi'
alias migrate='php artisan migrate --ansi'
alias rollback='php artisan migrate:rollback --ansi'
alias seed='php artisan db:seed --ansi'

# Development tools
alias pint='./vendor/bin/pint'
alias pest='./vendor/bin/pest'
alias phpstan='./vendor/bin/phpstan'
alias phpunit='./vendor/bin/phpunit'

# OPcache management (when enabled)
alias opcache-status='php -r "print_r(opcache_get_status());"'
alias opcache-reset='php -r "opcache_reset(); echo \"OPcache cleared!\n\";"'
alias opcache-info='php -r "print_r(opcache_get_configuration());"'

# Modern file listing (with colors)
alias ll='ls -alF --color=auto'
alias la='ls -A --color=auto'
alias l='ls -CF --color=auto'
alias ls='ls --color=auto'
alias tree='tree -I vendor -C'

# Quick navigation
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
EOF
}

# ============================================================================
# Generate .bashrc (always full development setup)
# ============================================================================
generate_bashrc_content() {
    cat << EOF
# .bashrc for ${APP_USER} user - DockerKit Local Development
# Generated automatically at $(date)

# If not running interactively, don't do anything
[[ \$- != *i* ]] && return

# Load aliases
if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

# Bash configuration optimized for development
export HISTCONTROL=ignoredups:erasedups
export HISTSIZE=${BASH_HISTSIZE}
export HISTFILESIZE=${BASH_HISTFILESIZE}
shopt -s histappend
shopt -s checkwinsize

# Save history immediately after each command (prevents loss on container restart)
PROMPT_COMMAND="\${PROMPT_COMMAND:+\$PROMPT_COMMAND\$'\n'}history -a"

# Enable bash completion
if ! shopt -oq posix; then
    if [ -f /usr/share/bash-completion/bash_completion ]; then
        . /usr/share/bash-completion/bash_completion
    elif [ -f /etc/bash_completion ]; then
        . /etc/bash_completion
    fi
fi

# Development environment variables (always enabled)
export EDITOR=\${EDITOR:-nano}
export PAGER=\${PAGER:-less}
export COMPOSER_MEMORY_LIMIT=-1
export PHP_IDE_CONFIG="${PHP_IDE_CONFIG:-}"
export APP_ENV=\${APP_ENV:-local}
export LOG_CHANNEL=\${LOG_CHANNEL:-stderr}

$(setup_shell_environment)
$(setup_colors)
$(setup_laravel_completion)
$(generate_optional_tools)
EOF
}

# ============================================================================
# Optional tools (fzf and starship only)
# ============================================================================
generate_optional_tools() {
    local content=""

    # fzf integration
    if [[ "${FZF_ENABLED}" = "1" ]] && command -v fzf >/dev/null 2>&1; then
        content="${content}
# fzf integration
source /opt/fzf/shell/key-bindings.bash 2>/dev/null || true
source /opt/fzf/shell/completion.bash 2>/dev/null || true
export FZF_DEFAULT_OPTS='--height 40% --layout=reverse --border'
export FZF_CTRL_T_OPTS=\"--preview 'cat {}' --preview-window=right:60%:wrap\"
"
    fi

    # Starship prompt
    if [[ "${STARSHIP_ENABLED}" = "1" ]] && command -v starship >/dev/null 2>&1; then
        content="${content}
# Starship prompt
eval \"\$(starship init bash)\"
"
    fi

    echo "$content"
}

# ============================================================================
# Main execution
# ============================================================================
main() {
    log_info "Configuring bash for DockerKit local development (user: ${APP_USER})"

    # Validation
    if ! validate_environment; then
        log_error "Environment validation failed"
        exit 1
    fi

    # Generate .bash_aliases
    if ! create_file_safely "${USER_HOME}/.bash_aliases" < <(generate_aliases_content); then
        log_error "Failed to create .bash_aliases"
        exit 1
    fi

    # Generate .bashrc
    if ! create_file_safely "${USER_HOME}/.bashrc" < <(generate_bashrc_content); then
        log_error "Failed to create .bashrc"
        exit 1
    fi

    # Setup readline configuration for better tab completion
    if ! setup_inputrc; then
        log_warn "Failed to setup readline configuration (non-critical)"
    fi

    # Set ownership (non-critical)
    set_ownership

    log_ok "Bash configuration completed successfully"
    echo ""

    # Ensure successful exit
    exit 0
}

main "$@"
